from __future__ import annotations

import os
import types
from dataclasses import dataclass, field, fields
from typing import Optional

import numpy as np

import nisarqa
from nisarqa import (
    HDF5Attrs,
    HDF5ParamGroup,
    InputFileGroupParamGroup,
    ProductPathGroupParamGroup,
    RootParamGroup,
    WorkflowsParamGroup,
    YamlAttrs,
    YamlParamGroup,
)

objects_to_skip = nisarqa.get_all(__name__)


@dataclass(frozen=True)
class RIFGInputFileGroupParamGroup(InputFileGroupParamGroup):
    """
    Parameters from the Input File Group runconfig group.

    This corresponds to the `groups: input_file_group` runconfig group.

    Parameters
    ----------
    qa_input_file : str
        The input NISAR product file name (with path).
    """

    # Required parameter - do not set a default
    qa_input_file: str = field(
        metadata={
            "yaml_attrs": YamlAttrs(
                name="qa_rifg_input_file",
                # Copy the description. InputFileGroupParamGroup only has
                # one field, so we'll cheat and access it via the [0] index.
                descr=fields(InputFileGroupParamGroup)[0]
                .metadata["yaml_attrs"]
                .descr,
            )
        }
    )


@dataclass(frozen=True)
class RUNWInputFileGroupParamGroup(InputFileGroupParamGroup):
    """
    Parameters from the Input File Group runconfig group.

    This corresponds to the `groups: input_file_group` runconfig group.

    Parameters
    ----------
    qa_input_file : str
        The input NISAR product file name (with path).
    """

    # Required parameter - do not set a default
    qa_input_file: str = field(
        metadata={
            "yaml_attrs": YamlAttrs(
                name="qa_runw_input_file",
                # Copy the description. InputFileGroupParamGroup only has
                # one field, so we'll cheat and access it via the [0] index.
                descr=fields(InputFileGroupParamGroup)[0]
                .metadata["yaml_attrs"]
                .descr,
            )
        }
    )


@dataclass(frozen=True)
class GUNWInputFileGroupParamGroup(InputFileGroupParamGroup):
    """
    Parameters from the Input File Group runconfig group.

    This corresponds to the `groups: input_file_group` runconfig group.

    Parameters
    ----------
    qa_input_file : str
        The input NISAR product file name (with path).
    """

    # Required parameter - do not set a default
    qa_input_file: str = field(
        metadata={
            "yaml_attrs": YamlAttrs(
                name="qa_gunw_input_file",
                # Copy the description. InputFileGroupParamGroup only has
                # one field, so we'll cheat and access it via the [0] index.
                descr=fields(InputFileGroupParamGroup)[0]
                .metadata["yaml_attrs"]
                .descr,
            )
        }
    )


# TODO - move to generic NISAR module (InSAR will need more thought)
@dataclass(frozen=True)
class InSARProductPathGroupParamGroup(ProductPathGroupParamGroup):
    """
    Parameters from the Product Path Group runconfig group.

    This corresponds to the `groups: product_path_group` runconfig group.

    Parameters
    ----------
    qa_output_dir : str, optional
        Filepath to the output directory to store NISAR QA output files.
        Defaults to './qa'.
    """

    qa_output_dir: str = field(
        default="./qa",
        metadata={
            "yaml_attrs": YamlAttrs(
                name="qa_output_dir",
                descr="""Output directory to store all QA output files.
                REQUIRED for QA. NOT REQUIRED if only running Product SAS.
                Because multiple InSAR products can be generated by a single
                ISCE3 runconfig, QA will make new product-specific directories
                here to store the corresponding product output files in.
                Ex: if the output dir is set to './qa' and QA is requested for
                an RIFG product, then QA will create './qa/rifg' and save the
                QA outputs there.""",
            )
        },
    )


@dataclass(frozen=True)
class RIFGProductPathGroupParamGroup(InSARProductPathGroupParamGroup):
    def __post_init__(self):
        # append subdirectory for the insar product to store its outputs
        object.__setattr__(
            self, "qa_output_dir", os.path.join(self.qa_output_dir, "rifg")
        )

        super().__post_init__()


@dataclass(frozen=True)
class RUNWProductPathGroupParamGroup(InSARProductPathGroupParamGroup):
    def __post_init__(self):
        # append subdirectory for the insar product to store its outputs
        object.__setattr__(
            self, "qa_output_dir", os.path.join(self.qa_output_dir, "runw")
        )

        super().__post_init__()


@dataclass(frozen=True)
class GUNWProductPathGroupParamGroup(InSARProductPathGroupParamGroup):
    def __post_init__(self):
        # append subdirectory for the insar product to store its outputs
        object.__setattr__(
            self, "qa_output_dir", os.path.join(self.qa_output_dir, "gunw")
        )

        super().__post_init__()


@dataclass(frozen=True)
class RIFGWorkflowsParamGroup(WorkflowsParamGroup):
    @staticmethod
    def get_path_to_group_in_runconfig():
        return ["runconfig", "groups", "qa", "rifg", "workflows"]


@dataclass(frozen=True)
class RUNWWorkflowsParamGroup(WorkflowsParamGroup):
    @staticmethod
    def get_path_to_group_in_runconfig():
        return ["runconfig", "groups", "qa", "runw", "workflows"]


@dataclass(frozen=True)
class GUNWWorkflowsParamGroup(WorkflowsParamGroup):
    @staticmethod
    def get_path_to_group_in_runconfig():
        return ["runconfig", "groups", "qa", "gunw", "workflows"]


@dataclass(frozen=True)
class HSIImageParamGroup(YamlParamGroup, HDF5ParamGroup):
    """
    Parameters to generate HSI Browse Image.

    Parameters
    ----------
    equalize_browse : bool, optional
        True to perform histogram equalization on the Intensity channel
        (the coherence magnitude layer) in the browse image PNG.
        (Browse image is in HSI color space.) PDF report will not be affected.
        See: https://scikit-image.org/docs/stable/auto_examples/color_exposure/plot_equalize.html
        Default is True.
    longest_side_max : int, optional
        The maximum number of pixels allowed for the longest side of the final
        2D multilooked browse image. Defaults to 2048 pixels.
    """

    equalize_browse: bool = field(
        default=True,
        metadata={
            "yaml_attrs": YamlAttrs(
                name="equalize_browse",
                descr="""True to perform histogram equalization on the Intensity channel
        (the coherence magnitude layer) in the browse image PNG.
        (Browse image is in HSI color space.) PDF report will not be affected.
        See: https://scikit-image.org/docs/stable/auto_examples/color_exposure/plot_equalize.html""",
            ),
            "hdf5_attrs": HDF5Attrs(
                name="equalizeBrowse",
                units="unitless",
                descr=(
                    "If True, histogram equalization was applied to the"
                    " intensity channel (coherence magnitude layer) in the"
                    " HSI browse image. (PDF report is not affected.)"
                ),
                group_path=nisarqa.STATS_H5_QA_PROCESSING_GROUP,
            ),
        },
    )

    longest_side_max: int = field(
        default=2048,
        metadata={
            "yaml_attrs": YamlAttrs(
                name="longest_side_max",
                descr="""The maximum number of pixels allowed for the longest
                side of the final 2D browse image. Defaults to 2048.""",
            )
        },
    )

    def __post_init__(self):
        # VALIDATE INPUTS

        # validate equalize_browse
        if not isinstance(self.equalize_browse, bool):
            raise TypeError(
                f"`equalize_browse` must be bool: {self.equalize_browse}"
            )

        # validate longest_side_max
        if not isinstance(self.longest_side_max, int):
            raise TypeError(
                f"longest_side_max must be a int: {self.longest_side_max}"
            )
        if self.longest_side_max <= 0:
            raise ValueError(
                f"`longest_side_max` must be positive: {self.longest_side_max}"
            )


@dataclass(frozen=True)
class UNWHSIImageParamGroup(HSIImageParamGroup):
    """
    Parameters to generate HSI Browse Image for unwrapped phase image.

    Parameters
    ----------
    equalize_browse : bool, optional
        True to perform histogram equalization on the Intensity channel
        (the coherence magnitude layer) in the browse image PNG.
        (Browse image is in HSI color space.) PDF report will not be affected.
        See: https://scikit-image.org/docs/stable/auto_examples/color_exposure/plot_equalize.html
        Default is True.
    longest_side_max : int, optional
        The maximum number of pixels allowed for the longest side of the final
        2D multilooked browse image. Defaults to 2048 pixels.
    rewrap : float or int or None, optional
        The multiple of pi to rewrap the unwrapped phase image when generating
        the HSI image(s). If None, no rewrapping will occur.
        Ex: If 3 is provided, the image is rewrapped to the interval [0, 3pi).
    """

    rewrap: Optional[float | int] = field(
        default=3,
        metadata={
            "yaml_attrs": YamlAttrs(
                name="rewrap",
                descr="""The multiple of pi to rewrap the unwrapped phase image
                    when generating the HSI image(s). If None, no rewrapping will occur.
                    Ex: If 3 is provided, the image is rewrapped to the interval [0, 3pi).
                    """,
            ),
            "hdf5_attrs": HDF5Attrs(
                name="rewrap",
                units="unitless",
                descr=(
                    "The multiple of pi for rewrapping the unwrapped phase"
                    " image in the HSI image(s). 'None' if no rewrapping"
                    " occurred. Example: If rewrap=3, the image was rewrapped"
                    " to the interval [0, 3pi)."
                ),
                group_path=nisarqa.STATS_H5_QA_PROCESSING_GROUP,
            ),
        },
    )

    def __post_init__(self):
        # VALIDATE INPUTS

        super().__post_init__()

        # validate rewrap
        if not isinstance(self.rewrap, (float, int, types.NoneType)):
            raise TypeError(
                f"{self.rewrap=} is {type(self.rewrap)}; "
                "must be float, int, or None."
            )

        if (self.rewrap is not None) and (self.rewrap <= 0):
            raise ValueError(f"{self.rewrap=}; must be a positive value.")


@dataclass(frozen=True)
class RIFGHSIImageParamGroup(HSIImageParamGroup):
    @staticmethod
    def get_path_to_group_in_runconfig():
        return ["runconfig", "groups", "qa", "rifg", "qa_reports", "hsi_img"]


@dataclass(frozen=True)
class RUNWHSIImageParamGroup(UNWHSIImageParamGroup):
    @staticmethod
    def get_path_to_group_in_runconfig():
        return ["runconfig", "groups", "qa", "runw", "qa_reports", "hsi_img"]


@dataclass(frozen=True)
class GUNWHSIImageParamGroup(UNWHSIImageParamGroup):
    @staticmethod
    def get_path_to_group_in_runconfig():
        return ["runconfig", "groups", "qa", "gunw", "qa_reports", "hsi_img"]


@dataclass
class RIFGRootParamGroup(RootParamGroup):
    """
    Dataclass of all *ParamGroup objects to process QA for NISAR RIFG products.

    `workflows` is the only required parameter; this *ParamGroup contains
    boolean attributes that indicate which QA workflows to run.

    All other parameters are optional, but they each correspond to (at least)
    one of the QA workflows. Based on the workflows set to True in
    `workflows`, certain others of these parameters will become required.

    Parameters
    ----------
    workflows : RIFGWorkflowsParamGroup
        QA Workflows parameters.
    input_f : RIFGInputFileGroupParamGroup or None, optional
        Input File Group parameters.
    prodpath : RIFGProductPathGroupParamGroup or None, optional
        Product Path Group parameters.
    hsi : RIFGHSIImageParamGroup or None, optional
        HSI Image Group parameters.
    """

    workflows: RIFGWorkflowsParamGroup

    # Shared parameters
    input_f: Optional[RIFGInputFileGroupParamGroup] = None
    prodpath: Optional[RIFGProductPathGroupParamGroup] = None

    hsi: Optional[RIFGHSIImageParamGroup] = None

    @staticmethod
    def get_mapping_of_workflows2param_grps(workflows):
        Grp = RootParamGroup.ReqParamGrp  # class object for our named tuple

        flag_any_workflows_true = any(
            [getattr(workflows, field.name) for field in fields(workflows)]
        )

        grps_to_parse = (
            Grp(
                flag_param_grp_req=flag_any_workflows_true,
                root_param_grp_attr_name="input_f",
                param_grp_cls_obj=RIFGInputFileGroupParamGroup,
            ),
            Grp(
                flag_param_grp_req=flag_any_workflows_true,
                root_param_grp_attr_name="prodpath",
                param_grp_cls_obj=RIFGProductPathGroupParamGroup,
            ),
            Grp(
                flag_param_grp_req=workflows.qa_reports,
                root_param_grp_attr_name="hsi",
                param_grp_cls_obj=RIFGHSIImageParamGroup,
            ),
        )

        return grps_to_parse

    @staticmethod
    def get_order_of_groups_in_yaml():
        # This order determines the order
        # the groups will appear in the runconfig.
        return (
            RIFGInputFileGroupParamGroup,
            RIFGProductPathGroupParamGroup,
            RIFGWorkflowsParamGroup,
            RIFGHSIImageParamGroup,
        )


@dataclass
class RUNWRootParamGroup(RootParamGroup):
    """
    Dataclass of all *ParamGroup objects to process QA for NISAR RUNW products.

    `workflows` is the only required parameter; this *ParamGroup contains
    boolean attributes that indicate which QA workflows to run.

    All other parameters are optional, but they each correspond to (at least)
    one of the QA workflows. Based on the workflows set to True in
    `workflows`, certain others of these parameters will become required.

    Parameters
    ----------
    workflows : RUNWWorkflowsParamGroup
        QA Workflows parameters.
    input_f : RUNWInputFileGroupParamGroup or None, optional
        Input File Group parameters.
    prodpath : RUNWProductPathGroupParamGroup or None, optional
        Product Path Group parameters.
    hsi : RUNWHSIImageParamGroup or None, optional
        HSI Image Group parameters.
    """

    # Shared parameters
    workflows: RUNWWorkflowsParamGroup
    input_f: Optional[RUNWInputFileGroupParamGroup] = None
    prodpath: Optional[RUNWProductPathGroupParamGroup] = None

    hsi: Optional[RUNWHSIImageParamGroup] = None

    @staticmethod
    def get_mapping_of_workflows2param_grps(workflows):
        Grp = RootParamGroup.ReqParamGrp  # class object for our named tuple

        flag_any_workflows_true = any(
            [getattr(workflows, field.name) for field in fields(workflows)]
        )

        grps_to_parse = (
            Grp(
                flag_param_grp_req=flag_any_workflows_true,
                root_param_grp_attr_name="input_f",
                param_grp_cls_obj=RUNWInputFileGroupParamGroup,
            ),
            Grp(
                flag_param_grp_req=flag_any_workflows_true,
                root_param_grp_attr_name="prodpath",
                param_grp_cls_obj=RUNWProductPathGroupParamGroup,
            ),
            Grp(
                flag_param_grp_req=workflows.qa_reports,
                root_param_grp_attr_name="hsi",
                param_grp_cls_obj=RUNWHSIImageParamGroup,
            ),
        )

        return grps_to_parse

    @staticmethod
    def get_order_of_groups_in_yaml():
        # This order determines the order
        # the groups will appear in the runconfig.
        return (
            RUNWInputFileGroupParamGroup,
            RUNWProductPathGroupParamGroup,
            RUNWWorkflowsParamGroup,
            RUNWHSIImageParamGroup,
        )


@dataclass
class GUNWRootParamGroup(RootParamGroup):
    """
    Dataclass of all *ParamGroup objects to process QA for NISAR GUNW products.

    `workflows` is the only required parameter; this *ParamGroup contains
    boolean attributes that indicate which QA workflows to run.

    All other parameters are optional, but they each correspond to (at least)
    one of the QA workflows. Based on the workflows set to True in
    `workflows`, certain others of these parameters will become required.

    Parameters
    ----------
    workflows : GUNWWorkflowsParamGroup
        QA Workflows parameters.
    input_f : GUNWInputFileGroupParamGroup or None, optional
        Input File Group parameters.
    prodpath : GUNWProductPathGroupParamGroup or None, optional
        Product Path Group parameters.
    hsi : GUNWHSIImageParamGroup or None, optional
        HSI Image Group parameters.
    """

    workflows: GUNWWorkflowsParamGroup

    # Shared parameters
    input_f: Optional[GUNWInputFileGroupParamGroup] = None
    prodpath: Optional[GUNWProductPathGroupParamGroup] = None

    hsi: Optional[GUNWHSIImageParamGroup] = None

    @staticmethod
    def get_mapping_of_workflows2param_grps(workflows):
        Grp = RootParamGroup.ReqParamGrp  # class object for our named tuple

        flag_any_workflows_true = any(
            [getattr(workflows, field.name) for field in fields(workflows)]
        )

        grps_to_parse = (
            Grp(
                flag_param_grp_req=flag_any_workflows_true,
                root_param_grp_attr_name="input_f",
                param_grp_cls_obj=GUNWInputFileGroupParamGroup,
            ),
            Grp(
                flag_param_grp_req=flag_any_workflows_true,
                root_param_grp_attr_name="prodpath",
                param_grp_cls_obj=GUNWProductPathGroupParamGroup,
            ),
            Grp(
                flag_param_grp_req=workflows.qa_reports,
                root_param_grp_attr_name="hsi",
                param_grp_cls_obj=GUNWHSIImageParamGroup,
            ),
        )

        return grps_to_parse

    @staticmethod
    def get_order_of_groups_in_yaml():
        # This order determines the order
        # the groups will appear in the runconfig.
        return (
            GUNWInputFileGroupParamGroup,
            GUNWProductPathGroupParamGroup,
            GUNWWorkflowsParamGroup,
            GUNWHSIImageParamGroup,
        )


__all__ = nisarqa.get_all(__name__, objects_to_skip)
